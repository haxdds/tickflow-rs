// Learning Goals:
// - Using derive macros
// - Deserializing JSON to Rust types
// - Pattern matching on enums
// - Debug trait for printing

mod ingestion;

use ingestion::{AlpacaMessage, Bar, Quote, Trade};

fn main() {
    println!("ðŸŽ“ COMMIT 2: Learning Serde & JSON Deserialization\n");
    
    // PART 1: Deserializing different message types
    println!("=== Part 1: Parsing JSON Messages ===\n");
    
    // Sample JSON messages from Alpaca API
    let messages = vec![
        r#"{"T":"success","msg":"authenticated"}"#,
        r#"{"T":"error","code":401,"msg":"invalid credentials"}"#,
        r#"{"T":"subscription","trades":["AAPL","TSLA"],"quotes":[],"bars":["AAPL"],"updated_bars":[],"daily_bars":[],"statuses":[],"lulds":[],"corrections":[],"cancel_errors":[]}"#,
        r#"{"T":"b","S":"AAPL","o":150.0,"h":152.5,"l":149.5,"c":151.0,"v":1000000,"t":"2024-01-01T10:00:00Z","n":1500,"vw":150.75}"#,
        r#"{"T":"q","S":"TSLA","bx":"NASDAQ","bp":250.10,"bs":100,"ax":"NASDAQ","ap":250.15,"as":200,"c":[],"z":"C","t":"2024-01-01T10:00:01Z"}"#,
        r#"{"T":"t","S":"MSFT","i":12345,"x":"NASDAQ","p":380.50,"s":50,"c":[],"z":"C","t":"2024-01-01T10:00:02Z"}"#,
    ];
    
    for (i, json) in messages.iter().enumerate() {
        println!("Message {}:", i + 1);
        println!("  Raw JSON: {}", json);
        
        // Rust Concept: DESERIALIZATION
        // serde_json::from_str attempts to parse JSON into our type
        // It returns Result<AlpacaMessage, serde_json::Error>
        match serde_json::from_str::<AlpacaMessage>(json) {
            Ok(msg) => {
                // Rust Concept: PATTERN MATCHING on enums
                match msg {
                    AlpacaMessage::Success { msg } => {
                        println!("  âœ“ Success: {}", msg);
                    }
                    AlpacaMessage::Error { code, msg } => {
                        println!("  âœ— Error {}: {}", code, msg);
                    }
                    AlpacaMessage::Subscription { trades, quotes, bars, .. } => {
                        println!("  ðŸ“¡ Subscription:");
                        println!("     Trades: {:?}", trades);
                        println!("     Quotes: {:?}", quotes);
                        println!("     Bars: {:?}", bars);
                    }
                    AlpacaMessage::Bar(bar) => {
                        println!("  ðŸ“Š Bar: {} O:${:.2} H:${:.2} L:${:.2} C:${:.2}",
                            bar.symbol, bar.open, bar.high, bar.low, bar.close);
                        println!("     Change: ${:.2} ({:.2}%)",
                            bar.price_change(), bar.price_change_percent());
                    }
                    AlpacaMessage::Quote(quote) => {
                        println!("  ðŸ’± Quote: {} Bid:${:.2} Ask:${:.2}",
                            quote.symbol, quote.bid_price, quote.ask_price);
                        println!("     Spread: ${:.4} ({:.2} bps)",
                            quote.spread(), quote.spread_bps());
                    }
                    AlpacaMessage::Trade(trade) => {
                        println!("  ðŸ“ˆ Trade: {} @ ${:.2} size:{} exchange:{}",
                            trade.symbol, trade.price, trade.size, trade.exchange);
                    }
                }
            }
            Err(e) => {
                println!("  âœ— Parse error: {}", e);
            }
        }
        println!();
    }
    
    // PART 2: Demonstrating the Debug trait
    println!("=== Part 2: Debug Trait ===\n");
    
    let bar_json = r#"{"T":"b","S":"AAPL","o":150.0,"h":152.5,"l":149.5,"c":151.0,"v":1000000,"t":"2024-01-01T10:00:00Z","n":1500,"vw":150.75}"#;
    let bar: Bar = serde_json::from_str(bar_json).unwrap();
    
    // Rust Concept: DEBUG TRAIT
    // {:?} uses the Debug trait (auto-generated by #[derive(Debug)])
    // {:#?} is "pretty debug" with nice formatting
    println!("Debug print (compact): {:?}", bar);
    println!();
    println!("Debug print (pretty):");
    println!("{:#?}", bar);
    println!();
    
    // PART 3: Error handling
    println!("=== Part 3: Handling Parse Errors ===\n");
    
    let invalid_json = r#"{"T":"invalid","unknown":"field"}"#;
    
    match serde_json::from_str::<AlpacaMessage>(invalid_json) {
        Ok(_) => println!("Unexpectedly succeeded!"),
        Err(e) => {
            println!("âœ“ Correctly caught parse error:");
            println!("  Error: {}", e);
        }
    }
    println!();
    
    let malformed_json = r#"{"T":"b","S":"AAPL" MISSING BRACE"#;
    
    match serde_json::from_str::<AlpacaMessage>(malformed_json) {
        Ok(_) => println!("Unexpectedly succeeded!"),
        Err(e) => {
            println!("âœ“ Correctly caught malformed JSON:");
            println!("  Error: {}", e);
        }
    }
    println!();
    
    println!("âœ… Commit 2 Complete!");
    println!("\nðŸ“š Key Concepts Learned:");
    println!("  â€¢ #[derive(Debug, Deserialize)] macros");
    println!("  â€¢ Tagged enums with #[serde(tag)]");
    println!("  â€¢ Field renaming with #[serde(rename)]");
    println!("  â€¢ Pattern matching on enums");
    println!("  â€¢ JSON parsing with serde_json");
    println!("  â€¢ Result type for error handling");
}